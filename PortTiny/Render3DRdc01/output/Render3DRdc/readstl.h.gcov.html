<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - Render3DRdc/readstl.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">Render3DRdc</a> - readstl.h<span style="font-size: 80%;"> (source / <a href="readstl.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">45</td>
            <td class="headerCovTableEntry">54</td>
            <td class="headerCovTableEntryMed">83.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-12-02 06:20:11</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">33.3 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #ifndef READ_STL_STRUCTS_AND_CLASSES_H</a>
<span class="lineNum">       2 </span>            : #define READ_STL_STRUCTS_AND_CLASSES_H
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">       5 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">       6 </span>            : #include &lt;string&gt;
<span class="lineNum">       7 </span>            : #include &lt;vector&gt;
<span class="lineNum">       8 </span>            : #include &lt;iostream&gt;
<span class="lineNum">       9 </span>            : #include &lt;string&gt;
<span class="lineNum">      10 </span>            : #include &lt;fstream&gt;
<span class="lineNum">      11 </span>            : #include &lt;vector&gt;
<span class="lineNum">      12 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      13 </span>            : #include &lt;list&gt;
<span class="lineNum">      14 </span>            : #include &lt;sstream&gt;
<span class="lineNum">      15 </span>            : #include &lt;iomanip&gt;
<span class="lineNum">      16 </span>            : #include &lt;locale&gt;
<span class="lineNum">      17 </span>            : #include &lt;cstdlib&gt;
<span class="lineNum">      18 </span>            : using namespace std;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : // define the vec3d struct (a 3D vector with three components)
<span class="lineNum">      21 </span>            : struct vec3d
<span class="lineNum">      22 </span>            : { 
<span class="lineNum">      23 </span>            :     double x;  /// x-component of the 3D vector
<span class="lineNum">      24 </span>            :     double y;  /// y-component of the 3D vector
<span class="lineNum">      25 </span>            :     double z;  /// z-component of the 3D vector
<a name="26"><span class="lineNum">      26 </span>            : };</a>
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span><span class="lineNoCov">          0 : vec3d Add3DPt(vec3d Pt1, vec3d Pt2)</span>
<span class="lineNum">      29 </span>            : {
<span class="lineNum">      30 </span>            :         vec3d tempPt;
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :         tempPt.x = Pt1.x + Pt2.x;</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :         tempPt.y = Pt1.y + Pt2.y;</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :         tempPt.z = Pt1.z + Pt2.z;</span>
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :         return tempPt;</span>
<a name="35"><span class="lineNum">      35 </span>            : }</a>
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span><span class="lineNoCov">          0 : vec3d operator + (const vec3d&amp;P1, const vec3d&amp;P2)</span>
<span class="lineNum">      38 </span>            : {
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :         return Add3DPt(P1, P2);</span>
<span class="lineNum">      40 </span>            : }
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // A triangular element is defined using the three vertices and a normal vector defining the orientation
<span class="lineNum">      43 </span>            : // of the element in relation to the surface of the solid object. The normal vector usually points outwards
<span class="lineNum">      44 </span>            : // for each surface element.
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : class triangle
<span class="lineNum">      47 </span>            : {
<span class="lineNum">      48 </span>            : public:
<span class="lineNum">      49 </span>            :     /// 3 components of the normal vector to the triangle
<span class="lineNum">      50 </span>            :     vec3d normal;
<span class="lineNum">      51 </span>            :     /// 3 coordinates of the three vertices of the triangle
<span class="lineNum">      52 </span>            :     vec3d point[3];
<a name="53"><span class="lineNum">      53 </span>            : };</a>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineCov">          1 : int inline read_binary_STL_file(std::string STL_filename,std::vector&lt;triangle&gt; &amp; facet,</span>
<span class="lineNum">      56 </span>            :                          double &amp; x_min, double &amp; x_max, double &amp; y_min, double &amp; y_max, double &amp; z_min, double &amp; z_max)
<span class="lineNum">      57 </span>            : {
<span class="lineNum">      58 </span>            :     // specify the location of STL files on this computer
<span class="lineNum">      59 </span><span class="lineCov">          2 :     std::string STL_files_path = &quot;&quot;;   </span>
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :     // declare an (input) file object
<span class="lineNum">      62 </span><span class="lineCov">          2 :     std::ifstream binaryInputFile;</span>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :     // open the STL file by using the full path and the name
<span class="lineNum">      65 </span>            :     // specify that the file is opened in &quot;read-only&quot; mode
<span class="lineNum">      66 </span>            :     // specify that the file is opened in binary format
<span class="lineNum">      67 </span><span class="lineCov">          1 :     binaryInputFile.open((STL_files_path + STL_filename).c_str(), std::ifstream::in | std::ifstream::binary);</span>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :     // check whether the file was opened successfully
<span class="lineNum">      70 </span>            :     // if yes then continue otherwise terminate program execution
<span class="lineNum">      71 </span><span class="lineCov">          1 :     if(binaryInputFile.fail())</span>
<span class="lineNum">      72 </span>            :     {
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         std::cout &lt;&lt; &quot;ERROR: Input STL file could not be opened!&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :         return (1);</span>
<span class="lineNum">      75 </span>            :     }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :     // position the pointer to byte number 80
<span class="lineNum">      78 </span><span class="lineCov">          1 :     binaryInputFile.seekg(80);</span>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :     // read the number of facets (triangles) in the STL geometry
<span class="lineNum">      81 </span>            :     int numberOfTriangles;
<span class="lineNum">      82 </span><span class="lineCov">          1 :     binaryInputFile.read((char*) &amp;numberOfTriangles, sizeof(int));</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :     // declare an object &quot;tri&quot; of type triangle (see main.h for the definition of the triangle class)
<span class="lineNum">      85 </span>            :     triangle tri;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :     // storage space for the &quot;unused bytes&quot; 
<span class="lineNum">      88 </span>            :     char unused_bytes[2];
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :     // initialize parameters that will be used to store the minimum and maximum extents of the geometry
<span class="lineNum">      91 </span>            :     // described by the STL file
<span class="lineNum">      92 </span><span class="lineCov">          1 :     x_min = 1e+30, x_max = -1e+30;</span>
<span class="lineNum">      93 </span><span class="lineCov">          1 :     y_min = 1e+30, y_max = -1e+30;</span>
<span class="lineNum">      94 </span><span class="lineCov">          1 :     z_min = 1e+30, z_max = -1e+30;</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :     // temporary floating point variable
<span class="lineNum">      97 </span>            :     float temp_float_var;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">      69452 :     for(int count=0;count&lt;numberOfTriangles;count++)</span>
<span class="lineNum">     100 </span>            :     {
<span class="lineNum">     101 </span>            :         // read the three components of the normal vector
<span class="lineNum">     102 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.normal.x = (double) temp_float_var;</span>
<span class="lineNum">     103 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.normal.y = (double) temp_float_var;</span>
<span class="lineNum">     104 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.normal.z = (double) temp_float_var;</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :         // read the three coordinates of vertex 1 
<span class="lineNum">     107 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[0].x = (double) temp_float_var;</span>
<span class="lineNum">     108 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[0].y = (double) temp_float_var;</span>
<span class="lineNum">     109 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[0].z = (double) temp_float_var;</span>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :         // read the three coordinates of vertex 2 
<span class="lineNum">     112 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[1].x = (double) temp_float_var;</span>
<span class="lineNum">     113 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[1].y = (double) temp_float_var;</span>
<span class="lineNum">     114 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[1].z = (double) temp_float_var;</span>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :         // read the three coordinates of vertex 3
<span class="lineNum">     117 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[2].x = (double) temp_float_var;</span>
<span class="lineNum">     118 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[2].y = (double) temp_float_var;</span>
<span class="lineNum">     119 </span><span class="lineCov">      69451 :         binaryInputFile.read((char*)&amp;temp_float_var,4); tri.point[2].z = (double) temp_float_var;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :         // read the 2 unused bytes
<span class="lineNum">     122 </span><span class="lineCov">      69451 :         binaryInputFile.read(unused_bytes,2);</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :         // update geometry extents along X, Y and Z based on vertex 1 of this triangle
<span class="lineNum">     125 </span><span class="lineCov">      69451 :         if (tri.point[0].x &lt; x_min) x_min = tri.point[0].x;</span>
<span class="lineNum">     126 </span><span class="lineCov">      69451 :         if (tri.point[0].x &gt; x_max) x_max = tri.point[0].x;</span>
<span class="lineNum">     127 </span><span class="lineCov">      69451 :         if (tri.point[0].y &lt; y_min) y_min = tri.point[0].y;</span>
<span class="lineNum">     128 </span><span class="lineCov">      69451 :         if (tri.point[0].y &gt; y_max) y_max = tri.point[0].y;</span>
<span class="lineNum">     129 </span><span class="lineCov">      69451 :         if (tri.point[0].z &lt; z_min) z_min = tri.point[0].z;</span>
<span class="lineNum">     130 </span><span class="lineCov">      69451 :         if (tri.point[0].z &gt; z_max) z_max = tri.point[0].z;</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :         // update geometry extents along X, Y and Z based on vertex 2 of this triangle
<span class="lineNum">     133 </span><span class="lineCov">      69451 :         if (tri.point[1].x &lt; x_min) x_min = tri.point[1].x;</span>
<span class="lineNum">     134 </span><span class="lineCov">      69451 :         if (tri.point[1].x &gt; x_max) x_max = tri.point[1].x;</span>
<span class="lineNum">     135 </span><span class="lineCov">      69451 :         if (tri.point[1].y &lt; y_min) y_min = tri.point[1].y;</span>
<span class="lineNum">     136 </span><span class="lineCov">      69451 :         if (tri.point[1].y &gt; y_max) y_max = tri.point[1].y;</span>
<span class="lineNum">     137 </span><span class="lineCov">      69451 :         if (tri.point[1].z &lt; z_min) z_min = tri.point[1].z;</span>
<span class="lineNum">     138 </span><span class="lineCov">      69451 :         if (tri.point[1].z &gt; z_max) z_max = tri.point[1].z;</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :         // update geometry extents along X, Y and Z based on vertex 3 of this triangle
<span class="lineNum">     141 </span><span class="lineCov">      69451 :         if (tri.point[2].x &lt; x_min) x_min = tri.point[2].x;</span>
<span class="lineNum">     142 </span><span class="lineCov">      69451 :         if (tri.point[2].x &gt; x_max) x_max = tri.point[2].x;</span>
<span class="lineNum">     143 </span><span class="lineCov">      69451 :         if (tri.point[2].y &lt; y_min) y_min = tri.point[2].y;</span>
<span class="lineNum">     144 </span><span class="lineCov">      69451 :         if (tri.point[2].y &gt; y_max) y_max = tri.point[2].y;</span>
<span class="lineNum">     145 </span><span class="lineCov">      69451 :         if (tri.point[2].z &lt; z_min) z_min = tri.point[2].z;</span>
<span class="lineNum">     146 </span><span class="lineCov">      69451 :         if (tri.point[2].z &gt; z_max) z_max = tri.point[2].z;</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :         // add data for this triangle to the &quot;facet&quot; vector
<span class="lineNum">     149 </span><span class="lineCov">      69451 :         facet.push_back(tri);</span>
<span class="lineNum">     150 </span>            :     }
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     // explicitly close the connection to the input STL file
<span class="lineNum">     153 </span><span class="lineCov">          1 :     binaryInputFile.close();</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineCov">          1 :     return (0);  // all is well</span>
<span class="lineNum">     156 </span>            : }
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : int inline read_ascii_STL_file(std::string STL_filename, std::vector&lt;triangle&gt; &amp; facet,
<span class="lineNum">     159 </span>            :                         double &amp; x_min, double &amp; x_max, double &amp; y_min, double &amp; y_max, double &amp; z_min, double &amp; z_max)
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span>            :     // specify the location of STL files on this computer
<span class="lineNum">     162 </span>            :     std::string STL_files_path = &quot;&quot;;   
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     // declare a (input) file object
<span class="lineNum">     165 </span>            :     std::ifstream asciiInputFile;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     // open the STL file by using the full path and the name
<span class="lineNum">     168 </span>            :     // specify that the file is opened in &quot;read-only&quot; mode
<span class="lineNum">     169 </span>            :     asciiInputFile.open((STL_files_path + STL_filename).c_str(), std::ifstream::in);
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :     // check whether the file was opened successfully
<span class="lineNum">     172 </span>            :     // if yes then continue otherwise terminate program execution
<span class="lineNum">     173 </span>            :     if(asciiInputFile.fail())
<span class="lineNum">     174 </span>            :     {
<span class="lineNum">     175 </span>            :         std::cout &lt;&lt; &quot;ERROR: Input STL file could not be opened!&quot; &lt;&lt; std::endl;
<span class="lineNum">     176 </span>            :         return(1); // error
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :     // read in the contents line by line until the file ends
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            :     // initialize counter for counting the number of lines in this file
<span class="lineNum">     182 </span>            :     int triangle_number = 0;  
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :     // declare an object &quot;tri&quot; of type triangle (see above for the definition of the triangle struct)
<span class="lineNum">     185 </span>            :     triangle tri;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :     // declare some string objects
<span class="lineNum">     188 </span>            :     std::string junk;
<span class="lineNum">     189 </span>            :     std::string string1,string2;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     // read in the first line (until the /n delimiter) and store it in the string object &quot;line&quot;
<span class="lineNum">     192 </span>            :     getline(asciiInputFile,junk);
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :     // initialize parameters that will be used to store the minimum and maximum extents of the geometry
<span class="lineNum">     195 </span>            :     // described by the STL file
<span class="lineNum">     196 </span>            :     x_min = 1e+30, x_max = -1e+30;
<span class="lineNum">     197 </span>            :     y_min = 1e+30, y_max = -1e+30;
<span class="lineNum">     198 </span>            :     z_min = 1e+30, z_max = -1e+30;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :     // begin loop to read the rest of the file until the file ends
<span class="lineNum">     201 </span>            :     while(true)
<span class="lineNum">     202 </span>            :     {
<span class="lineNum">     203 </span>            :         // read the components of the normal vector
<span class="lineNum">     204 </span>            :         asciiInputFile &gt;&gt; string1 &gt;&gt; string2 &gt;&gt; tri.normal.x &gt;&gt; tri.normal.y &gt;&gt; tri.normal.z;        //  1
<span class="lineNum">     205 </span>            :         // continue reading this line until the \n delimiter
<span class="lineNum">     206 </span>            :         getline(asciiInputFile,junk);                                                                //  1
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :         // read the next line until the \n delimiter
<span class="lineNum">     209 </span>            :         getline(asciiInputFile,junk);                                                                //  2
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :         // read the (x,y,z) coordinates of vertex 1            
<span class="lineNum">     212 </span>            :         asciiInputFile &gt;&gt; string1 &gt;&gt; tri.point[0].x &gt;&gt; tri.point[0].y &gt;&gt; tri.point[0].z;             //  3
<span class="lineNum">     213 </span>            :         getline(asciiInputFile,junk);                                                                //  3
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :         // read the (x,y,z) coordinates of vertex 2            
<span class="lineNum">     216 </span>            :         asciiInputFile &gt;&gt; string1 &gt;&gt; tri.point[1].x &gt;&gt; tri.point[1].y &gt;&gt; tri.point[1].z;             //  4
<span class="lineNum">     217 </span>            :         getline(asciiInputFile,junk);                                                                //  4
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :         // read the (x,y,z) coordinates of vertex 3            
<span class="lineNum">     220 </span>            :         asciiInputFile &gt;&gt; string1 &gt;&gt; tri.point[2].x &gt;&gt; tri.point[2].y &gt;&gt; tri.point[2].z;             //  5
<span class="lineNum">     221 </span>            :         getline(asciiInputFile,junk);                                                                //  5
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :         // read some more junk
<span class="lineNum">     224 </span>            :         getline(asciiInputFile,junk);                                                                //  6
<span class="lineNum">     225 </span>            :         getline(asciiInputFile,junk);                                                                //  7
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :         // update geometry extents along X, Y and Z based on vertex 1 of this triangle
<span class="lineNum">     228 </span>            :         if (tri.point[0].x &lt; x_min) x_min = tri.point[0].x;
<span class="lineNum">     229 </span>            :         if (tri.point[0].x &gt; x_max) x_max = tri.point[0].x;
<span class="lineNum">     230 </span>            :         if (tri.point[0].y &lt; y_min) y_min = tri.point[0].y;
<span class="lineNum">     231 </span>            :         if (tri.point[0].y &gt; y_max) y_max = tri.point[0].y;
<span class="lineNum">     232 </span>            :         if (tri.point[0].z &lt; z_min) z_min = tri.point[0].z;
<span class="lineNum">     233 </span>            :         if (tri.point[0].z &gt; z_max) z_max = tri.point[0].z;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :         // update geometry extents along X, Y and Z based on vertex 2 of this triangle
<span class="lineNum">     236 </span>            :         if (tri.point[1].x &lt; x_min) x_min = tri.point[1].x;
<span class="lineNum">     237 </span>            :         if (tri.point[1].x &gt; x_max) x_max = tri.point[1].x;
<span class="lineNum">     238 </span>            :         if (tri.point[1].y &lt; y_min) y_min = tri.point[1].y;
<span class="lineNum">     239 </span>            :         if (tri.point[1].y &gt; y_max) y_max = tri.point[1].y;
<span class="lineNum">     240 </span>            :         if (tri.point[1].z &lt; z_min) z_min = tri.point[1].z;
<span class="lineNum">     241 </span>            :         if (tri.point[1].z &gt; z_max) z_max = tri.point[1].z;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :         // update geometry extents along X, Y and Z based on vertex 3 of this triangle
<span class="lineNum">     244 </span>            :         if (tri.point[2].x &lt; x_min) x_min = tri.point[2].x;
<span class="lineNum">     245 </span>            :         if (tri.point[2].x &gt; x_max) x_max = tri.point[2].x;
<span class="lineNum">     246 </span>            :         if (tri.point[2].y &lt; y_min) y_min = tri.point[2].y;
<span class="lineNum">     247 </span>            :         if (tri.point[2].y &gt; y_max) y_max = tri.point[2].y;
<span class="lineNum">     248 </span>            :         if (tri.point[2].z &lt; z_min) z_min = tri.point[2].z;
<span class="lineNum">     249 </span>            :         if (tri.point[2].z &gt; z_max) z_max = tri.point[2].z;
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :         // break out of the while loop if &quot;end-of-file&quot; becomes true
<span class="lineNum">     252 </span>            :         if (asciiInputFile.eof()) break;
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :         // increment the triangle number
<span class="lineNum">     255 </span>            :         triangle_number++;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :         // add data for this triangle to the &quot;facet&quot; vector
<span class="lineNum">     258 </span>            :         facet.push_back(tri);
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            :     // end while loop
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :     // explicitly close the output file
<span class="lineNum">     263 </span>            :     asciiInputFile.close();
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :     return (0);   // all is well
<span class="lineNum">     266 </span>            : }
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : int inline getStlGeometryInput(char* filename,
<span class="lineNum">     270 </span>            :                      std::vector&lt;triangle&gt; &amp; facet, 
<span class="lineNum">     271 </span>            :                      double &amp; x_min, double &amp; x_max, 
<span class="lineNum">     272 </span>            :                      double &amp; y_min, double &amp; y_max, 
<span class="lineNum">     273 </span>            :                      double &amp; z_min, double &amp; z_max)
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span>            :     // open the STL file and read its contents
<span class="lineNum">     276 </span>            :     // get the name of the STL file (command line input)
<span class="lineNum">     277 </span>            :     std::string STL_filename = filename;
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :     // BEGIN algorithm from ParaView to detect whether the STL file is ASCII or BINARY
<span class="lineNum">     280 </span>            :     // open the STL file specified by the user as &quot;read-only&quot; and in &quot;binary&quot; mode
<span class="lineNum">     281 </span>            :     // and store the pointer to the file buffer in &quot;fp&quot;
<span class="lineNum">     282 </span>            :     FILE *fp = fopen((char*)STL_filename.c_str(),&quot;rb&quot;);
<span class="lineNum">     283 </span>            :     // specify how many bytes of the file will be read to calculate the percentage of characters
<span class="lineNum">     284 </span>            :     // that are non-ASCII
<span class="lineNum">     285 </span>            :     unsigned long length = 256;
<span class="lineNum">     286 </span>            :     // dynamically allocate a buffer for storing the contents of the file
<span class="lineNum">     287 </span>            :     // based on the length specified above
<span class="lineNum">     288 </span>            :     unsigned char *buffer = new unsigned char[length];
<span class="lineNum">     289 </span>            :     // read an array of &quot;length&quot; elements from the STL file, where each element is 1 byte in size
<span class="lineNum">     290 </span>            :     // store the result in the buffer defined above
<span class="lineNum">     291 </span>            :     // fread returns the number of bytes successfully read and this is stored in &quot;read_length&quot; 
<span class="lineNum">     292 </span>            :     size_t read_length = fread(buffer,1,length,fp);
<span class="lineNum">     293 </span>            :     // close the STL file
<span class="lineNum">     294 </span>            :     fclose(fp);
<span class="lineNum">     295 </span>            :     // loop over contents and count
<span class="lineNum">     296 </span>            :     size_t text_count = 0;
<span class="lineNum">     297 </span>            :     const unsigned char *ptr = buffer;
<span class="lineNum">     298 </span>            :     const unsigned char *buffer_end = buffer + read_length;
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :     // loop over the entire buffer, starting at the memory location pointed to by &quot;ptr&quot;
<span class="lineNum">     301 </span>            :     while(ptr != buffer_end)
<span class="lineNum">     302 </span>            :     {
<span class="lineNum">     303 </span>            :         if ( (*ptr &gt;= 0x20 &amp;&amp; *ptr &lt;=0x7F) || *ptr == '\n' || *ptr == '\r' || *ptr == '\t')
<span class="lineNum">     304 </span>            :         {
<span class="lineNum">     305 </span>            :             text_count++;  // Yay! we have an ASCII character!
<span class="lineNum">     306 </span>            :         }
<span class="lineNum">     307 </span>            :         ptr++;    // move on to the next &quot;byte&quot;
<span class="lineNum">     308 </span>            :     }
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :     // free memory
<span class="lineNum">     311 </span>            :     delete [] buffer;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :     // calculate the fraction of characters(bytes) in part of the STL file that are BINARY
<span class="lineNum">     314 </span>            :     double current_percent_bin = (static_cast&lt;double&gt; (read_length - text_count) / static_cast&lt;double&gt; (read_length));
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :     // anything above the cut-off value below means that this STL file is of type BINARY
<span class="lineNum">     317 </span>            :     double percent_bin = 0.05;
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     std::string STL_filetype;
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     if(current_percent_bin &gt;= percent_bin)
<span class="lineNum">     322 </span>            :     {
<span class="lineNum">     323 </span>            :         STL_filetype = &quot;binary&quot;;
<span class="lineNum">     324 </span>            :     }
<span class="lineNum">     325 </span>            :     else
<span class="lineNum">     326 </span>            :     {
<span class="lineNum">     327 </span>            :         STL_filetype = &quot;ascii&quot;;
<span class="lineNum">     328 </span>            :     }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :     // END algorithm from ParaView to detect whether the STL file is ASCII or BINARY
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :     std::cout &lt;&lt; &quot;Input Geometry File = &quot; &lt;&lt; STL_filename &lt;&lt; &quot; (&quot; &lt;&lt; STL_filetype &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
<span class="lineNum">     333 </span>            :  
<span class="lineNum">     334 </span>            :     // function call to open the ascii file and read the content
<span class="lineNum">     335 </span>            :     if (STL_filetype == &quot;ascii&quot;)
<span class="lineNum">     336 </span>            :     {
<span class="lineNum">     337 </span>            :         // call the function to read the ASCII file
<span class="lineNum">     338 </span>            :         // if all goes well, this function will return a value of 0
<span class="lineNum">     339 </span>            :         int error = read_ascii_STL_file(STL_filename,facet,x_min,x_max,y_min,y_max,z_min,z_max);
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :         // if something goes wrong, the above function will return a value of 1
<span class="lineNum">     342 </span>            :         if (error == 1) 
<span class="lineNum">     343 </span>            :         {
<span class="lineNum">     344 </span>            :             return(1);       // exit returning an error
<span class="lineNum">     345 </span>            :         }
<span class="lineNum">     346 </span>            :     }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :     // function call to open the binary file and read the content
<span class="lineNum">     349 </span>            :     if (STL_filetype == &quot;binary&quot;) 
<span class="lineNum">     350 </span>            :     {
<span class="lineNum">     351 </span>            :         // call the function to read the BINARY file
<span class="lineNum">     352 </span>            :         // if all goes well, this function will return a value of 0
<span class="lineNum">     353 </span>            :         int error = read_binary_STL_file (STL_filename,facet,x_min,x_max,y_min,y_max,z_min,z_max);
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :         // if something goes wrong, the above function will return a value of 1
<span class="lineNum">     356 </span>            :         if (error == 1) 
<span class="lineNum">     357 </span>            :         {
<span class="lineNum">     358 </span>            :             return(1);       // exit returning an error
<span class="lineNum">     359 </span>            :         }
<span class="lineNum">     360 </span>            :     }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :     if (STL_filetype != &quot;ascii&quot; &amp;&amp; STL_filetype != &quot;binary&quot;) 
<span class="lineNum">     363 </span>            :     {
<span class="lineNum">     364 </span>            :         std::cout &lt;&lt; &quot;ERROR: Unable to find out whether the STL file is ascii or binary&quot; &lt;&lt; std::endl;
<span class="lineNum">     365 </span>            :         return(1);
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span>            :  
<span class="lineNum">     368 </span>            :     // print the number of triangles
<span class="lineNum">     369 </span>            :     std::cout &lt;&lt; &quot;The number of triangles in the STL file = &quot; &lt;&lt; facet.size() &lt;&lt; std::endl;
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :     // print the domain extent along X, Y and Z
<span class="lineNum">     372 </span>            :     std::cout &lt;&lt; std::endl;
<span class="lineNum">     373 </span>            :     std::cout &lt;&lt; &quot;X range : &quot; &lt;&lt; x_min &lt;&lt; &quot; to &quot; &lt;&lt; x_max &lt;&lt; &quot; (delta = &quot; &lt;&lt; x_max - x_min &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
<span class="lineNum">     374 </span>            :     std::cout &lt;&lt; &quot;Y range : &quot; &lt;&lt; y_min &lt;&lt; &quot; to &quot; &lt;&lt; y_max &lt;&lt; &quot; (delta = &quot; &lt;&lt; y_max - y_min &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
<span class="lineNum">     375 </span>            :     std::cout &lt;&lt; &quot;Z range : &quot; &lt;&lt; z_min &lt;&lt; &quot; to &quot; &lt;&lt; z_max &lt;&lt; &quot; (delta = &quot; &lt;&lt; z_max - z_min &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
<span class="lineNum">     376 </span>            :     std::cout &lt;&lt; std::endl;
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            :     return (0);  // all is well
<span class="lineNum">     379 </span>            : }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
